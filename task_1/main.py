from typing import Any, NamedTuple, Hashable


"""
Визначаємо вузол який буде зберігатись у зв'язаних списках для полегшення роботи в коді,
оскільки для даної задачі `tuple` є ідеальним рішенням, але в нього є один "недолік"
а саме, доступ до його елементів тільки по індексах, що ускладнює читання, розуміння та
підтримку коду. Тому для покращення якості коду можна використовувати namedtuple,
оскільки він має ті ж самі властивості, що і tuple, але має доступ до його елементів по імені,
а також він займає трохи більше місця в пам'яті ніж звичайний tuple, і при цьому значно
менше ніж словник. Також аналогом іменованого кортежу може бути `dataclass`
"""
Node = NamedTuple('Node', [
    ('key', Hashable),
    ('value', Any),
])

Map = list[list[Node]]


class HashMap:
    """
    Проста реалізація класу хеш-карти.

    Дана реалізація забезпечує оптимальну роботу хеш-карти при невеликій кількості елементів
    які зберігаються в ній. Проте вона не є ідеальною, оскільки з ростом кількості елементів
    ймовірність колізії збільшується, що призводить до росту вкладених списків, і збільшує
    часові затрати на отримання, встановлення чи оновлення конкретного значення

    Суть проблеми хешування, полягає в тому, що в хеш-функцію може передаватись необмежена
    кількість даних, але на виході з функції ми будемо отримувати значення певного розміру,
    що в свою чергу неминуче буде призводити до колізії
    """
    __size: int
    __map: Map

    def __init__(self, size: int = 64) -> None:
        """
        Значення змінної size є критично важливим для ефективної роботи даної хеш-карти,
        оскільки вона визначає кількість вкладених масивів в які будуть розподілятись дані.
        Якщо в хеш-карті зберегти невелику кількість значень (наприклад, близько десяти записів),
        то, ймовірність, що у вкладених масивах кількість збережених даних буде більше двох
        елементів дуже мала, тому складність такого пошуку буде O(1), оскільки потрібно
        вирахувати хеш ключа, і в отриманому масиві з більшою ймовірність буде всього одне
        значення яке буде відповідати нашому ключеві. Проте, якщо в нас буде збережено сотні
        тисяч записів, то у кожному вкладеному списку будуть тисячі записів серед яких потрібно
        буде шляхом ітерування знайти відповідний ключ, що робить ефективність O(n).

        Для захисту стану атрибутів класу від зовнішнього впливу краще використовувати перед
        назвою змінною два нижніх підкреслення для забезпечення "приватності" даних атрибутів,
        проте доступ із зовні можна буде отримати по повній назві яку інтерпретатор динамічно
        створює і вона виглядає наступним чином: instance._HashMap__size
        """
        self.__size: int = size
        """
        Створення двомірного списку для збереження в ньому даних.
        Важливо звернути увагу на те, щоб масив був заповнений масивами
        які не являються посиланням на один одного, до чого може привести
        використання такого коду: self.__map: Map = [[]] * self.__size
        """
        self.__map: Map = [[] for _ in range(self.__size)]

    def _hash(self, key: Hashable) -> int:
        """
        Оптимальний варіант для обчислення хеша це використовувати вбудовану функцію hash,
        оскільки вона значно простіше визначає хеш об'єкта ніж реалізації з ручним обчисленням
        хешу за допомогою функції ord чи інших способів, оскільки вона просто викликає метод
        __hash__ в цих об'єктів. Цим самим, нам не потрібно прописувати механізм обчислення
        хешів для різних типів даних, оскільки більшість типів даних в python вже мають
        визначений метод __hash__, який забезпечує обчислення хешу.

        Вбудований тип даних None використовує вбудоване хеш-значення об'єкта.
        Це означає, що для об'єктів типу None буде генеруватися однакове хеш-значення,
        що буде призводити до колізії.


        Після обчислення хешу за допомогою операції % (модуль) здійснюється обмеження хешу
        до діапазону від 0 до self.size - 1 для того щоб отримане значення не виходило за
        межі масив self.map
        """
        return hash(key) % self.__size

    def add(self, key: Hashable, value: Any) -> None:
        """
        Метод реалізує додавання нового значення до хеш-карти.
        """

        key_hash: int = self._hash(key)
        key_value: Node = Node(key, value)

        """
        Обробку виключень IndexError, TypeError можна не додавати оскільки метод _hash завжди
        повертає числове значення яке не перевищує розміри масиву, а неможливість виникнення
        виключення AttributeError забезпечується обмеженням несанкціонованого доступу із зовні
        на атрибут self.__map і цим самим змінити його коректне значення встановлене при
        ініціалізації класу.
        """
        node_list: list[Node] = self.__map[key_hash]   # Пошук потрібного списку за хешем

        for i, node in enumerate(node_list):
            if node.key == key:
                node_list[i] = key_value  # Замінюємо вузол повність, оскільки неможливо модифікувати його значення
                return

        node_list.append(key_value)

    def put(self, key: Hashable, value: Any) -> None:
        """
        Метод реалізує оновлення значення в хеш-карті.
        """

        hash_key: int = self._hash(key)
        key_value: Node = Node(key, value)

        node_list: list[Node] = self.__map[hash_key]  # Пошук потрібного списку за хешем
        if node_list:
            for i, node in enumerate(node_list):
                if node.key == key:
                    node_list[i] = key_value
                    return

        node_list.append(key_value)

    def get(self, key: Hashable, default: Any | None = None) -> Any | None:
        """
        Метод реалізує отримання значення з хеш-карти.
        """

        key_hash: int = self._hash(key)

        node_list: list[Node] = self.__map[key_hash]  # Пошук потрібного списку за хешем
        if node_list:
            for node in node_list:
                if node.key == key:
                    return node.value
        return default

    def delete(self, key: Hashable) -> bool:
        """
        Метод реалізує отримання значення з хеш-карти.
        """

        key_hash: int = self._hash(key)

        node_list: list[Node] = self.__map[key_hash]  # Пошук потрібного списку за хешем
        if not node_list:
            return False

        for i in range(len(node_list)):
            if node_list[i].key == key:
                node_list.pop(i)
                return True

        """
        Також можна реалізувати видалення вузла із списку за допомогою методу remove,
        що буде виглядати трішки простіше простіше, але видалення конкретного елемента
        зі списку за його індексом є ефективнішим за метод remove(),
        оскільки pop(i) видаляє елемент за його точним індексом, що займає O(1) часу,
        тоді як remove() повинен шукати перше входження елемента в списку,
        що може займати O(n) часу у гіршому випадку.

        for node in node_list:
            if node.key == key:
                node_list.remove(node)
                return True
        """

        return False

    def __str__(self) -> str:
        return str(self.__map)


def main() -> None:
    hash_map = HashMap()
    hash_map.add('Tom', 'Hello!')
    hash_map.add('Bob', 'Hi there!')
    hash_map.add('Kate', 'Good morning!')
    hash_map.add('Jane', 'Good afternoon!')
    hash_map.put('Bob', 'Aloha!')
    hash_map.delete('Kate')

    print('Tom says:', hash_map.get('Tom'))
    print('Bob says:', hash_map.get('Bob'))
    print('Kate says:', hash_map.get('Kate', 'Oops!'))


if __name__ == '__main__':
    main()
